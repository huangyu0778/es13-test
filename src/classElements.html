<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script>
                    class Father {
                      constructor() {
                        this._num = 0;
                      }
                    }
                    const son = new Father();
                    console.log(son._num); // _num是一些约定成俗表示私有的写法，但是并不能阻止被访问和修改
      // ----------------------------------------------------------------
                    class Mother {
                      #num = 0;
                    }
                    const daughter = new Mother();
                    // console.log(daughter.#num);
                    // 现在通过#前缀来表示私有，当我们访问或者修改时就会跑出错误
                    // Property '#num' is not accessible outside class 'Mother' because it has a private identifier.
      //--------------------------------------------------------------
                    // 除了私有字段，方法和访问器同样可以通过 # 前缀来表示私有
                    class Counter {
                      #length;
                      constructor() {
                        console.log(this.#getLength);
                        this.#initLength = 0;
                        console.log(this.#getLength);
                      }
                      get #getLength() {
                        return this.#length;
                      }
                      set #initLength(length) {
                        this.#length = length + 1;
                      }
                    }
                    const counte = new Counter();
      // console.log(counte.#length);
      // Property '#length' is not accessible outside class 'Counter' because it has a private identifier.
      //--------------------------------------------------------------
                    class Status {
                      #title = 0;

                      static baseTitle = 100;

                      // 静态方法可以通过 this 访问静态字段
                      static getDoubleBaseTitle() {
                        return this.baseTitle * 2;
                      }
                    }

                    // 静态字段和方法通过类本身访问
                    console.log(Status.baseTitle); // 100
                    console.log(Status.getDoubleBaseTitle()); // 200

                    // 实例不能访问静态字段和方法
                    const status = new Status();
                    console.log(status.baseTitle); // undefined
      //--------------------------------------------------------------
                    class Adress {
                      #num = 0;

                      static #baseGz = 100;

                      static getDoubleBaseGz() {
                        return this.#baseGz * 2;
                      }

                      getBaseGz() {
                        return Adress.#baseGz;
                      }
                    }

        // 私有静态字段不能被直接访问
        // console.log(Adress.#baseGz); // Uncaught SyntaxError: Private field '#baseNum' must be declared in an enclosing class
        // 同类静态方法可以访问私有静态字段
                    console.log(Adress.getDoubleBaseGz()); // 200

                    // 实例可以访问同类下的私有静态字段和方法
                    const counter = new Adress();
                    console.log(counter.getBaseGz()); // 100
        //---------------------------------------------------------------
        // #x in obj 主要是检测一个对象或实例是否存在私有字段或方法
                    class C {
                      #brand;

                      #method() {}

                      get #getter() {}

                      static isC(obj) {
                        // return #bbbb in obj && #method in obj && #getter in obj;
                        // Uncaught SyntaxError: Private field '#brrrrrand' must be declared in an enclosing class
                      }
                    }
          // -------------------------------------------------------------
          // 新提案允许我们利用 /d 标识符来表示想要匹配字符串的开始和结束索引。
          // 在此之前我们并不能完成知道所有匹配的字符在目标字符串的位置
                    const re1 = /a+(z)?/;

                    const s1 = 'xaaaz';
                    const m1 = re1.exec(s1);

                    console.log(m1);
                    console.log(m1[0]); // 'aaaz'
                    console.log(m1[1]); // 'z'
          //-------------------------------------------------------------
          // 现在通过 /d 标识符，匹配结果会多出一个属性 .indices
                    const rq1 = /a+(z)?/d;

                    const h1 = 'xaaaz';
                    const k1 = rq1.exec(h1);

                    console.log(k1);
                    console.log(k1.indices[0]); // [1, 5]
                    console.log(h1.slice(...k1.indices[0])); // 'aaaz'
                    console.log(k1.indices[1]); // [4, 5]
                    console.log(h1.slice(...k1.indices[1])); // 'z'
          //------------------------------------------------------------
          // Error Cause
                    async function getSolution() {
                    const rawResource = await fetch('//domain/resource-a')
                  .catch(err => {
                    // 平时我们要抛出错误有以下几种方式：
                    // 1. throw new Error('Download raw resource failed: ' + err.message);
                    // 2. const wrapErr = new Error('Download raw resource failed');
                    //    wrapErr.cause = err;
                    //    throw wrapErr;
                    // 3. class CustomError extends Error {
                    //      constructor(msg, cause) {
                    //        super(msg);
                    //        this.cause = cause;
                    //      }
                    //    }
                    //    throw new CustomError('Download raw resource failed', err);
                  })
                const jobResult = doComputationalHeavyJob(rawResource);
                await fetch('//domain/upload', { method: 'POST', body: jobResult });
              }

              await doJob(); // => TypeError: Failed to fetch
              // 在新的提案中，加入了 cause 来收集原因，规范化整个错误抛出和收集：
              async function doJob() {
              const rawResource = await fetch('//domain/resource-a')
              .catch(err => {
              // 抛出一个低等级错误err，可以通过 cause 包装成高等级错误 Error
              throw new Error('Download raw resource failed', { cause: err });
              });
              const jobResult = doComputationalHeavyJob(rawResource);
              await fetch('//domain/upload', { method: 'POST', body: jobResult })
              .catch(err => {
              throw new Error('Upload job result failed', { cause: err });
              });
             }

            try {
            await doJob();
            } catch (e) {
            console.log(e);
            console.log('Caused by', e.cause);
           }
         // Error: Upload job result failed
         // Caused by TypeError: Failed to fetch
         //------------------------------------------------------------
                    // .at()
                    // 我们要访问数组某一项，通常是这么做：
                    const arr = [1, 2, 3];

                    console.log(arr[0]); // 1
                    console.log(arr[arr.length - 1]); // 3
                    // 从上面可以看出，访问前面的数组还好，倒过来访问就略显难受，特别是数组动态算出来的，比如：
                    console.log(
                      [1, 2, 3].map((v) => v + 1)[[1, 2, 3].map((v) => v + 1).length - 1]
                    ); // 4
                    // 上面这种情况，我们不得不用一个变量存起来。
                    // 新增 Array.prototype.at 就可以解决问题，这个跟 String.prototype.at 用法基本一致。
                    const arry = [1, 2, 3];
                    console.log(arry[arry.length - 1]); // 3
                    // ↓↓
                    console.log(arry.at(-1)); // 3

                    // 动态算出来也能变得简洁
                    console.log(
                      [1, 2, 3].map((v) => v + 1)[[1, 2, 3].map((v) => v + 1).length - 1]
                    ); // 4
                    // ↓↓
                    console.log([1, 2, 3].map((v) => v + 1).at(-1)); // 4
            // -------------------------------------------------------------
            // 我们要遍历一个对象，会这么写
                    let obj = {
                      a: '1',
                      b: '3',
                    };
                    for (var k in obj) {
                      if (obj.hasOwnProperty(k)) {
                        // 获取可枚举对象
                        console.log(k);
                      }
                    }
                    //  eslint 会弹出提示
                    //  解决问题，我们改成这样
                    Object.prototype.hasOwnProperty.call(obj, 'key');
                    // console.log(obj);
                    // 来到重点了，新的提案简化了：
                    Object.prototype.hasOwnProperty.call(obj, 'key');
                    // ↓↓
                    Object.hasOwn(obj, 'key');
    </script>
  </body>
</html>
